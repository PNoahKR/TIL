# 그래프 탐색

## 탐색 기법

1. 깊이 우선 탐색 (Depth First Search, DFS)
2. 너비 우선 탐색 (Breadth First Search, BFS)

---

# 깊이 우선 탐색 (DFS)

## DFS (Depth First Search)

- 깊이 우선 탐색
- 시작 시점에서 출발해 **한 방향으로 탐색**
- 진행 할 수 없다면 **마지막에 만난 지점으로 돌아와 다른 방향 다시 탐색**
- **후입 선출(LIFO : Last in First out)** 구조의 스택(Stack) 사용
- 재귀함수는 System Stack을 활용하므로 간단하게 구현 가능

## 트리 탐색

1. 루트 노드 → Stack Push
2. Stack → Empty 가 될 때까지 반복 수행
    1. 현재 노드 → Stack Pop
    2. 현재 노드의 모든 자식 → Stack Push

```java
DFS(v) {                          //v : 루트노드
	stack.push(v)
	while(not stack.isEmpty) {
		curr = stack.pop
		for w in (curr의 모든 자식)
			stack.push(w)
	}
}
```

## 트리 탐색 (재귀 함수)

1. 현재 노드 (v) 방문
2. (v) 의 자식 노드 (w)를 차례로 재귀 호출

```java
DSF(v) {
	v 방문;
	for w in (v의 모든 자식) {
		DFS(w);
	}
}
```

## 그래프 탐색 (재귀 함수)

```java
// G : 그래프. visited : 방문 배열
DFS(v) {
	visited[ v ] <- TRUE   // v 방문 설정
	
	FOR each all w in adjacency( G, v )
		IF visited[w] != TRUE
			DFS(w)
}
```

# 너비 우선 탐색 (BFS)

## BFS(Breadth First Search)

- 너비 우선 탐색
- **시작 지점에 인접한 순으로 탐색**을 시작함
- **인접한 지점을 모두 방문**하였다면 **다음으로 인접한 지점을 방문**함
- 선입 선출(FIFO : First-In First-Out) 구조의 **Queue 자료구조**를 사용
- 너비 우선 탐색은 시작 지점과 끝 지점이 주어졌을 때 **최단 길이**를 구할 수 있음

## 트리 탐색

1. 루트 노드 **Queue에 삽입**
2. Queue가 **공백이 될 때 까지 반복 수행**
    1. Queue에서 원소 (Curr) 꺼내기
    2. 해당 원소 방문
    3. Curr의 자식 노드 Queue에 삽입

```java
BFS(v) {
	Queue 생성;
	Queue.add(v);
	WHILE (!Queue.isEmpty()) {
		curr <- Queue.deq();
		curr 방문
		FOR w (curr의 모든 자식노드)
			Queue.add(w);
	}
}
```

## 그래프 탐색

```java
BFS(G,v) // 그래프 G, 탐색 시작점 v

큐 생성
시작점 v를 큐에 삽입
점 v를 방문한 것으로 표시
WHILE 큐가 비어있지 않은 경우
		t <- 큐의 첫번째 원소 반환
		FOR t와 연결된 모든 선에 대해
				u <- t의 이웃점
				u가 방문 되지 않은 곳이면,
				u를 큐에 넣고, 방문한 것으로 표시
```