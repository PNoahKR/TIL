# νΈλ¦¬(Tree)

- **κ³„μΈµμ  κµ¬μ΅°**λ¥Ό ν‘ν„ν•λ” **λΉ„μ„ ν•** **μλ£κµ¬μ΅°**
- **1 : N** μ κ΄€κ³„λ¥Ό κ°€μ§€λ” μλ£κµ¬μ΅°
- ν• κ° μ΄μƒμ λ…Έλ“λ΅ μ΄λ£¨μ–΄μ§„ μ ν• μ§‘ν•©
- μƒμ„ μ›μ†μ—μ„ ν•μ„ μ›μ†λ΅ **λ‚΄λ ¤κ°€λ©΄μ„ ν™•μ¥**λλ” νΈλ¦¬(λ‚λ¬΄)λ¨μ–‘μ κµ¬μ΅°
- **μ‚¬μ΄ν΄ (μν™) μ—†μ**

## νΈλ¦¬ μ©μ–΄

![118.png](img/118.png)

---

# μ΄μ§„ νΈλ¦¬ (Binary Tree)

- κ° λ…Έλ“κ°€ **μµλ€ 2κ°μ μμ‹**(μ™Όμ½, μ¤λ¥Έμ½)μ„ κ°€μ§€λ” νΈλ¦¬  
  β†’ μμ‹ λ…Έλ“λ” **0 / 1 / 2 κ°**
- **νΉμ • λ λ²¨ i** μ—μ„μ λ…Έλ“μ μµλ€ κ°μλ” **$2^i$κ°**
- **λ†’μ΄κ°€ h**μΈ μ΄μ§„ νΈλ¦¬κ°€ κ°€μ§ μ μλ” λ…Έλ“μ **μµμ† κ°μλ” (h+1)**κ°, **μµλ€ κ°μλ” ( $2^{h+1} - 1$ )** κ°

## ν¬ν™” μ΄μ§„ νΈλ¦¬ (Perfect Binary Tree)

- **λ¨λ“  λ λ²¨**μ— λ…Έλ“κ°€ ν¬ν™” μƒνƒλ΅ μ°¨ μλ” μ΄μ§„ νΈλ¦¬
- λ¦¬ν”„ λ…Έλ“μ κΉμ΄**κ°€ κ°™μ**
- λ†’μ΄κ°€ hμΌ λ•, μµλ€ λ…Έλ“ κ°μμΈ **( $2^{h+1} - 1$ ) κ° λ…Έλ“λ¥Ό κ°€μ§„ μ΄μ§„ νΈλ¦¬**

## μ • μ΄μ§„ νΈλ¦¬ (Full Binary Tree)

- λ¨λ“  λ…Έλ“κ°€ **0κ° λλ” 2κ°μ μμ‹μ„ κ°€μ§„ μ΄μ§„ νΈλ¦¬**
- μμ‹ λ…Έλ“κ°€ 1κ°μΈ λ…Έλ“λ” μ΅΄μ¬ν•μ§€ μ•μ
- λ¦¬ν”„ λ…Έλ“μ κΉμ΄λ” **λ‹¤λ¥Ό μ μμ**

## μ™„μ „ μ΄μ§„ νΈλ¦¬ (Complete Binary Tree) (β…β…β…β…β…)

- λ§μ§€λ§‰ λ λ²¨μ„ μ μ™Έν• **λ¨λ“  λ λ²¨μ΄ κ½‰ μ°¨ μκ³ **, λ§μ§€λ§‰ λ λ²¨μ λ…Έλ“λ” **μ™Όμ½λ¶€ν„° μ±„μ›μ§€λ” νΈλ¦¬**

## νΈν–¥ μ΄μ§„ νΈλ¦¬(Skewed Binary Tree)

- λ¨λ“  λ…Έλ“κ°€ **ν•μ½ μμ‹ λ…Έλ“λ§ κ°€μ§**
- μ™Όμ½ νΈν–¥ μ΄μ§„ νΈλ¦¬
- μ¤λ¥Έμ½ νΈν–¥ μ΄μ§„ νΈλ¦¬

## μ΄μ§„ νƒμƒ‰ νΈλ¦¬ (Binary Search Tree, BST)

- **μ™Όμ½ μμ‹ < λ¶€λ¨ < μ¤λ¥Έμ½ μμ‹ μ κ·μΉ™**μ„ λ”°λ¥΄λ” μ΄μ§„ νΈλ¦¬  
  β†’ μ¤‘μ„μν ν•λ©΄ μ¤λ¦„μ°¨μμΌλ΅ μ •λ ¬ κ°€λ¥!

## κ· ν• μ΄μ§„ νΈλ¦¬ (Balanced Binary Tree)

- λ¨λ“  μ„λΈ νΈλ¦¬μ λ†’μ΄ μ°¨μ΄κ°€ μΌμ • μ΄ν•λ΅ μ μ§€λλ” νΈλ¦¬
- AVL νΈλ¦¬, λ λ“-λΈ”λ™ νΈλ¦¬ λ“±μ΄ κ· ν• μ΄μ§„ νΈλ¦¬μ— μ†ν•¨

## λ°°μ—΄μ„ μ΄μ©ν• μ΄μ§„ νΈλ¦¬ ν‘ν„

? β†’ μ™„μ „ μ΄μ§„ νΈλ¦¬μ—¬μ•Ό ν•λ”κ°€?  
β‡’ λ§λ‹¤! κ·Όλ° κ°€μƒμ λ…Έλ“λ΅ μ²λ¦¬ν•  μ λ„ μλ‹¤!!

- μ΄μ§„ νΈλ¦¬μ— **κ° λ…Έλ“ λ²νΈλ¥Ό** λ‹¤μκ³Ό κ°™μ΄ **λ¶€μ—¬** (λ£¨νΈ λ…Έλ“ : 1λ²)
- λ λ²¨ Nμ— μλ” λ…Έλ“μ— λ€ν•μ—¬ μ™Όμ½λ¶€ν„° μ¤λ¥Έμ½μΌλ΅ **$2^n$ λ¶€ν„° $2^{n+1}-1$ κΉμ§€ λ²νΈλ¥Ό μ°¨λ΅€λ΅ λ¶€μ—¬**

  ![119.png](img/119.png)

- λ…Έλ“ λ²νΈκ°€ i μΈ λ…Έλ“κ°€ λ¶€λ¨ λ…Έλ“μΈ λ²νΈ : $[i/2]$  
  β†’ [ ] λ” λ‚΄λ¦Όμ²λ¦¬
- λ…Έλ“ λ²νΈκ°€ i μΈ λ…Έλ“κ°€ μ™Όμ½ μμ‹ λ…Έλ“μΈ λ²νΈ : $2 * i$
- λ…Έλ“ λ²νΈκ°€ i μΈ λ…Έλ“κ°€ μ¤λ¥Έμ½ μμ‹ λ…Έλ“μΈ λ²νΈ : $2 * i + 1$
- λ λ²¨ nμ λ…Έλ“ μ‹μ‘ λ²νΈ : $2^n$

![120.png](img/120.png)

- 1μ°¨μ› λ°°μ—΄μ„ μ΄μ©ν• μ €μ¥ λ°©μ‹

  ![121.png](img/121.png)

- 2μ°¨μ› λ°°μ—΄μ„ μ΄μ©ν• μ™Όμ½ μμ‹, μ¤λ¥Έμ½ μμ‹ μ €μ¥ λ°©μ‹ (λ¶€λ¨μ μ •λ³΄λ¥Ό μ €μ¥ν•  μλ„ μμ)

  ![122.png](img/122.png)


## λ°°μ—΄μ„ μ΄μ©ν• μ΄μ§„ νΈλ¦¬ ν‘ν„ λ‹¨μ 

- νΈν–¥ μ΄μ§„ νΈλ¦¬μ κ²½μ°μ— μ‚¬μ©ν•μ§€ μ•λ” **λ°°μ—΄ μ›μ†μ— λ€ν• λ©”λ¨λ¦¬ κ³µκ°„ λ‚­λΉ„ λ°μƒ**
- νΈλ¦¬μ μ¤‘κ°„μ— μƒλ΅μ΄ λ…Έλ“λ¥Ό μ‚½μ…ν•κ±°λ‚ κΈ°μ΅΄μ λ…Έλ“λ¥Ό μ‚­μ ν•  κ²½μ° λ°°μ—΄μ ν¬κΈ° λ³€κ²½μ΄ μ–΄λ ¤μ›€

## μ—°κ²° λ¦¬μ¤νΈλ¥Ό μ΄μ©ν• μ΄μ§„ νΈλ¦¬ ν‘ν„

- λ°°μ—΄μ λ‹¨μ μ„ λ³΄μ™„ν•κΈ° μ„ν•΄ **μ—°κ²°λ¦¬μ¤νΈλ¥Ό μ΄μ©**ν•μ—¬ νΈλ¦¬λ¥Ό ν‘ν„ν•  μ μμ
- μ΄μ§„ νΈλ¦¬μ λ¨λ“  λ…Έλ“λ” **μµλ€ 2κ°μ μμ‹ λ…Έλ“λ¥Ό κ°€μ§€λ―€λ΅ μΌμ •ν• κµ¬μ΅°μ λ…Έλ“λ¥Ό ν™μ©**

  ![123.png](img/123.png)

- μ™„μ „ μ΄μ§„ νΈλ¦¬ μμ‹

  ![124.png](img/124.png)


---

# μ΄μ§„ νΈλ¦¬ μν(Traversal)

## μν(Traversal)

- νΈλ¦¬μ λ…Έλ“λ“¤μ„ **μ¤‘λ³µλμ§€ μ•κ² μ „λ¶€ λ°©λ¬Έν•λ” κ²ƒμ„ λ§ν•¨**
- νΈλ¦¬λ” λΉ„μ„ ν• κµ¬μ΅° μ΄λ―€λ΅ μ„ ν• κµ¬μ΅°μ™€ κ°™μ΄ μ„ ν›„ μ—°κ²° κ΄€κ³„λ¥Ό μ• μ μ—†μ!

## κΈ°λ³Έ μν(Traversal)

BFS, DFS β€¦ good!

- μ „μ„ μν(preorder traversal) : **Vβ†’Lβ†’R**  
  β†’ λ¶€λ¨ λ…Έλ“ λ°©λ¬Έ ν›„, μμ‹ λ…Έλ“λ¥Ό μΆ, μ° μμ„λ΅ λ°©λ¬Έ
- μ¤‘μ„ μν(inorder traversal) : **Lβ†’Vβ†’R**  
  β†’ μ™Όμ½ μμ‹ λ…Έλ“, λ¶€λ¨ λ…Έλ“, μ¤λ¥Έμ½ μμ‹ λ…Έλ“ μμΌλ΅ λ°©λ¬Έ
- ν›„μ„ μν(postorder traversal) : **Lβ†’Rβ†’V**  
  β†’ μμ‹ λ…Έλ“λ¥Ό μΆ, μ° μμ„λ΅ λ°©λ¬Έν• ν›„, λ¶€λ¨ λ…Έλ“λ¥Ό λ°©λ¬Έ
- **λ³€ν•μ§€ μ•λ” κ²ƒ : L β†’ R**

## μ „μ„ μν(preorder traversal)

1. **ν„μ¬ λ…Έλ“** nμ„ **λ°©λ¬Έν•μ—¬ μ²λ¦¬**ν•λ‹¤ β†’ V
2. **ν„μ¬ λ…Έλ“** nμ **μ™Όμ½ μ„λΈ νΈλ¦¬λ΅ μ΄λ™**ν•λ‹¤ β†’ L
3. **ν„μ¬ λ…Έλ“** nμ **μ¤λ¥Έμ½ μ„λΈ νΈλ¦¬λ΅ μ΄λ™**ν•λ‹¤ β†’ R
- μ „μ„ μν μ•κ³ λ¦¬μ¦

```java
preorder_traverse(T) {
		if (T is not null) {
				visit(T)
				preorder_traverse(T.left)
				preorder_traverse(T.right)
		}
}
```

![125.png](img/125.png)

## μ¤‘μ„ μν(inorder traversal)

1. **ν„μ¬ λ…Έλ“** nμ **μ™Όμ½ μ„λΈ νΈλ¦¬λ΅ μ΄λ™**ν•λ‹¤ β†’ L
2. **ν„μ¬ λ…Έλ“** nμ„ **λ°©λ¬Έν•μ—¬ μ²λ¦¬**ν•λ‹¤ β†’ V
3. **ν„μ¬ λ…Έλ“** nμ **μ¤λ¥Έμ½ μ„λΈ νΈλ¦¬λ΅ μ΄λ™**ν•λ‹¤ β†’ R
- μ¤‘μ„ μν μ•κ³ λ¦¬μ¦

```java
inorder_traverse(T) {
		if (T is not null) {
				preorder_traverse(T.left)
				visit(T)
				preorder_traverse(T.right)
		}
}
```

## ν›„μ„ μν(postorder traversal)

1. **ν„μ¬ λ…Έλ“** nμ **μ™Όμ½ μ„λΈ νΈλ¦¬λ΅ μ΄λ™**ν•λ‹¤ β†’ L
2. **ν„μ¬ λ…Έλ“** nμ **μ¤λ¥Έμ½ μ„λΈ νΈλ¦¬λ΅ μ΄λ™**ν•λ‹¤ β†’ R
3. **ν„μ¬ λ…Έλ“** nμ„ **λ°©λ¬Έν•μ—¬ μ²λ¦¬**ν•λ‹¤ β†’ V  
- ν›„μ„ μν μ•κ³ λ¦¬μ¦

```java
postorder_traverse(T) {
		if (T is not null) {
				preorder_traverse(T.left)
				preorder_traverse(T.right)
				visit(T)
		}
}
```

---

# μ¤ν”„λΌμΈ

## νΈλ¦¬

### νΈλ¦¬μ κ°λ…

- **λΉ„μ„ ν• κµ¬μ΅°**
- μ›μ†λ“¤ κ°„μ— **1:n κ΄€κ³„**λ¥Ό κ°€μ§€λ” μλ£κµ¬μ΅°
- μ›μ†λ“¤ κ°„μ— **κ³„μΈµκ΄€κ³„**λ¥Ό κ°€μ§€λ” κ³„μΈµν• μλ£κµ¬μ΅°
- μƒμ„ μ›μ†μ—μ„ ν•μ„ μ›μ†λ΅ λ‚΄λ ¤κ°€λ©΄μ„ ν™•μ¥λλ” **νΈλ¦¬(λ‚λ¬΄)λ¨μ–‘**μ κµ¬μ΅°

### νΈλ¦¬μ μ •μ

> ν• κ° μ΄μƒμ λ…Έλ“λ΅ μ΄λ£¨μ–΄μ§„ μ ν• μ§‘ν•©μ΄λ©° λ‹¤μ μ΅°κ±΄μ„ λ§μ΅±ν•λ‹¤.
>
- λ…Έλ“ μ¤‘ **μµμƒμ„ λ…Έλ“**λ¥Ό **λ£¨νΈ(root)**λΌ ν•λ‹¤
- λ‚λ¨Έμ§€ λ…Έλ“λ“¤μ€ n(β‰¥0)κ°μ λ¶„λ¦¬ μ§‘ν•© T1,β€¦,TNμΌλ΅ λ¶„λ¦¬λ  μ μλ‹¤
- μ΄λ“¤ T1, β€¦, TNμ€ κ°κ° ν•λ‚μ νΈλ¦¬κ°€ λλ©°(**μ¬κ·€μ  μ •μ**) λ£¨νΈμ **μ„λΈνΈλ¦¬(subtree)**λΌ ν•λ‹¤

### νΈλ¦¬ μ©μ–΄ μ •λ¦¬

| μ©μ–΄ | μ„¤λ… |
| --- | --- |
| **λ…Έλ“(node)** | νΈλ¦¬μ μ›μ† |
| **κ°„μ„ (edge)** | λ…Έλ“λ¥Ό μ—°κ²°ν•λ” μ„ . λ¶€λ¨ λ…Έλ“μ™€ μμ‹ λ…Έλ“λ¥Ό μ—°κ²° |
| **λ£¨νΈ λ…Έλ“(root node)** | νΈλ¦¬μ μ‹μ‘ λ…Έλ“ |
| **ν•μ  λ…Έλ“(sibling node)** | κ°™μ€ λ¶€λ¨ λ…Έλ“μ μμ‹ λ…Έλ“λ“¤ |
| **μ΅°μƒ λ…Έλ“** | κ°„μ„ μ„ λ”°λΌ λ£¨νΈ λ…Έλ“κΉμ§€ μ΄λ¥΄λ” κ²½λ΅μ— μλ” λ¨λ“  λ…Έλ“λ“¤ |
| **μ„λΈ νΈλ¦¬(subtree)** | λ¶€λ¨ λ…Έλ“μ™€ μ—°κ²°λ κ°„μ„ μ„ λμ—μ„ λ• μƒμ„±λλ” νΈλ¦¬ |
| **μμ† λ…Έλ“** | μ„λΈ νΈλ¦¬μ— μλ” ν•μ„ λ λ²¨μ λ…Έλ“λ“¤ |

### μ°¨μμ™€ λ†’μ΄

### μ°¨μ(degree)

- **λ…Έλ“μ μ°¨μ**: λ…Έλ“μ— μ—°κ²°λ μμ‹ λ…Έλ“μ μ
- **νΈλ¦¬μ μ°¨μ**: νΈλ¦¬μ— μλ” λ…Έλ“μ μ°¨μ μ¤‘μ—μ„ κ°€μ¥ ν° κ°’
- **λ‹¨λ§ λ…Έλ“(λ¦¬ν”„ λ…Έλ“)**: μ°¨μκ°€ 0μΈ λ…Έλ“. μμ‹ λ…Έλ“κ°€ μ—†λ” λ…Έλ“

### λ†’μ΄(height)

- **λ…Έλ“μ λ†’μ΄**: λ£¨νΈμ—μ„ λ…Έλ“μ— μ΄λ¥΄λ” κ°„μ„ μ μ. λ…Έλ“μ λ λ²¨
- **νΈλ¦¬μ λ†’μ΄**: νΈλ¦¬μ— μλ” λ…Έλ“μ λ†’μ΄ μ¤‘μ—μ„ κ°€μ¥ ν° κ°’. μµλ€ λ λ²¨

---

## μ΄μ§„ νΈλ¦¬

### μ΄μ§„ νΈλ¦¬μ μ •μ

- λ¨λ“  λ…Έλ“λ“¤μ΄ **2κ°μ μ„λΈνΈλ¦¬**λ¥Ό κ°–λ” νΉλ³„ν• ν•νƒμ νΈλ¦¬
- κ° λ…Έλ“κ°€ μμ‹ λ…Έλ“λ¥Ό **μµλ€ν• 2κ°κΉμ§€λ§** κ°€μ§ μ μλ” νΈλ¦¬
    - **μ™Όμ½ μμ‹ λ…Έλ“(left child node)**
    - **μ¤λ¥Έμ½ μμ‹ λ…Έλ“(right child node)**

### μ΄μ§„ νΈλ¦¬μ νΉμ„±

- λ λ²¨ iμ—μ„μ λ…Έλ“μ μµλ€ κ°μλ” **2^iκ°**
- λ†’μ΄κ°€ hμΈ μ΄μ§„ νΈλ¦¬κ°€ κ°€μ§ μ μλ” λ…Έλ“μ κ°μ
    - **μµμ† κ°μ**: (h+1)κ°
    - **μµλ€ κ°μ**: (2^(h+1)-1)κ°

### μ΄μ§„ νΈλ¦¬μ μΆ…λ¥

### 1. ν¬ν™” μ΄μ§„ νΈλ¦¬(Full Binary Tree)

- λ¨λ“  λ λ²¨μ— λ…Έλ“κ°€ **ν¬ν™”μƒνƒ**λ΅ μ°¨ μλ” μ΄μ§„ νΈλ¦¬
- λ†’μ΄κ°€ hμΌ λ•, μµλ€μ λ…Έλ“ κ°μμΈ **(2^(h+1)-1)**μ λ…Έλ“λ¥Ό κ°€μ§„ μ΄μ§„ νΈλ¦¬
- λ£¨νΈλ¥Ό 1λ²μΌλ΅ ν•μ—¬ **2^(h+1)-1κΉμ§€ μ •ν•΄μ§„ μ„μΉ**μ— λ€ν• λ…Έλ“ λ²νΈλ¥Ό κ°€μ§

### 2. μ™„μ „ μ΄μ§„ νΈλ¦¬(Complete Binary Tree)

- λ†’μ΄κ°€ hμ΄κ³  λ…Έλ“ μκ°€ nκ°μΌ λ• (λ‹¨, h+1 β‰¤ n < 2^(h+1)-1)
- **ν¬ν™” μ΄μ§„ νΈλ¦¬μ λ…Έλ“ λ²νΈ 1λ²λ¶€ν„° nλ²κΉμ§€ λΉ μλ¦¬κ°€ μ—†λ”** μ΄μ§„ νΈλ¦¬

### 3. νΈν–¥ μ΄μ§„ νΈλ¦¬(Skewed Binary Tree)

- λ†’μ΄ hμ— λ€ν• μµμ† κ°μμ λ…Έλ“λ¥Ό κ°€μ§€λ©΄μ„ **ν•μ½ λ°©ν–¥μ μμ‹ λ…Έλ“λ§**μ„ κ°€μ§„ μ΄μ§„ νΈλ¦¬
- **μ™Όμ½ νΈν–¥ μ΄μ§„ νΈλ¦¬**, **μ¤λ¥Έμ½ νΈν–¥ μ΄μ§„ νΈλ¦¬**

---

## μ΄μ§„ νΈλ¦¬μ ν‘ν„

### λ°°μ—΄μ„ μ΄μ©ν• ν‘ν„

### λ…Έλ“ λ²νΈ λ¶€μ—¬ κ·μΉ™

- λ£¨νΈμ λ²νΈλ¥Ό **1**λ΅ ν•¨
- λ λ²¨ nμ— μλ” λ…Έλ“μ— λ€ν•μ—¬ μ™Όμ½λ¶€ν„° μ¤λ¥Έμ½μΌλ΅ **2^nλ¶€ν„° 2^(n+1)-1κΉμ§€** λ²νΈλ¥Ό μ°¨λ΅€λ΅ λ¶€μ—¬

### λ…Έλ“ λ²νΈμ μ„±μ§

- λ…Έλ“ λ²νΈκ°€ iμΈ λ…Έλ“μ **λ¶€λ¨ λ…Έλ“ λ²νΈ**: $βi/2β‹$
- λ…Έλ“ λ²νΈκ°€ iμΈ λ…Έλ“μ **μ™Όμ½ μμ‹ λ…Έλ“ λ²νΈ**: $2*i$
- λ…Έλ“ λ²νΈκ°€ iμΈ λ…Έλ“μ **μ¤λ¥Έμ½ μμ‹ λ…Έλ“ λ²νΈ**: $2*i+1$
- λ λ²¨ nμ **λ…Έλ“ λ²νΈ μ‹μ‘ λ²νΈ**: $2^n$

### λ°°μ—΄ ν¬κΈ°

- λ†’μ΄κ°€ hμΈ μ΄μ§„ νΈλ¦¬λ¥Ό μ„ν• λ°°μ—΄μ ν¬κΈ°: **2^(h+1)-1**

### λ°°μ—΄ ν‘ν„μ λ‹¨μ 

- **νΈν–¥ μ΄μ§„ νΈλ¦¬**μ κ²½μ° μ‚¬μ©ν•μ§€ μ•λ” λ°°μ—΄ μ›μ†μ— λ€ν• **λ©”λ¨λ¦¬ κ³µκ°„ λ‚­λΉ„** λ°μƒ
- νΈλ¦¬μ μ¤‘κ°„μ— μƒλ΅μ΄ λ…Έλ“λ¥Ό μ‚½μ…ν•κ±°λ‚ κΈ°μ΅΄μ λ…Έλ“λ¥Ό μ‚­μ ν•  κ²½μ° **λ°°μ—΄μ ν¬κΈ° λ³€κ²½μ΄ μ–΄λ ¤μ›** λΉ„ν¨μ¨μ 

### λ°°μ—΄μ„ μ΄μ©ν• μν κµ¬ν„

```java
// λ°°μ—΄λ΅ κµ¬ν„λ μ΄μ§„ νΈλ¦¬μ μν
class ArrayBinaryTree {
    private int[] tree;
    private int size;

    public ArrayBinaryTree(int capacity) {
        this.tree = new int[capacity + 1]; // 1λ¶€ν„° μ‹μ‘
        this.size = 0;
    }

    // μ „μ„ μν (λ°°μ—΄ λ²„μ „)
    public void preorderTraversal(int index) {
        if (index <= size && tree[index] != 0) {
            System.out.print(tree[index] + " "); // λ°©λ¬Έ
            preorderTraversal(index * 2);        // μ™Όμ½ μμ‹
            preorderTraversal(index * 2 + 1);    // μ¤λ¥Έμ½ μμ‹
        }
    }

    // μ¤‘μ„ μν (λ°°μ—΄ λ²„μ „)
    public void inorderTraversal(int index) {
        if (index <= size && tree[index] != 0) {
            inorderTraversal(index * 2);         // μ™Όμ½ μμ‹
            System.out.print(tree[index] + " "); // λ°©λ¬Έ
            inorderTraversal(index * 2 + 1);     // μ¤λ¥Έμ½ μμ‹
        }
    }

    // ν›„μ„ μν (λ°°μ—΄ λ²„μ „)
    public void postorderTraversal(int index) {
        if (index <= size && tree[index] != 0) {
            postorderTraversal(index * 2);       // μ™Όμ½ μμ‹
            postorderTraversal(index * 2 + 1);   // μ¤λ¥Έμ½ μμ‹
            System.out.print(tree[index] + " "); // λ°©λ¬Έ
        }
    }
}
```

### μ—°κ²°λ¦¬μ¤νΈλ¥Ό μ΄μ©ν• ν‘ν„

- λ°°μ—΄μ„ μ΄μ©ν• μ΄μ§„ νΈλ¦¬ ν‘ν„μ λ‹¨μ μ„ λ³΄μ™„ν•κΈ° μ„ν•΄ μ‚¬μ©
- μ΄μ§„ νΈλ¦¬μ λ¨λ“  λ…Έλ“λ” μµλ€ 2κ°μ μμ‹ λ…Έλ“λ¥Ό κ°€μ§€λ―€λ΅ **μΌμ •ν• κµ¬μ΅°μ λ‹¨μ μ—°κ²° λ¦¬μ¤νΈ λ…Έλ“**λ¥Ό μ‚¬μ©ν•μ—¬ κµ¬ν„

```
λ…Έλ“ κµ¬μ΅°: [left | λ°μ΄ν„° | right]
             β†“               β†“
    μ™Όμ½ μμ‹ λ…Έλ“       μ¤λ¥Έμ½ μμ‹ λ…Έλ“
```

---

## μ΄μ§„ νΈλ¦¬μ μ €μ¥ λ°©λ²•

### 1. λ¶€λ¨ λ²νΈλ¥Ό μΈλ±μ¤λ΅ μμ‹ λ²νΈλ¥Ό μ €μ¥

```java
// λ¶€λ¨ β†’ μμ‹ κ΄€κ³„ μ €μ¥
int[] c1 = new int[N+1];  // μ²« λ²μ§Έ μμ‹
int[] c2 = new int[N+1];  // λ‘ λ²μ§Έ μμ‹

for (int i = 1; i <= N; i++) {
    int p = scanner.nextInt();  // λ¶€λ¨
    int c = scanner.nextInt();  // μμ‹

    if (c1[p] == 0) {
        c1[p] = c;
    } else {
        c2[p] = c;
    }
}
```

### 2. μμ‹ λ²νΈλ¥Ό μΈλ±μ¤λ΅ λ¶€λ¨ λ²νΈλ¥Ό μ €μ¥

```java
// μμ‹ β†’ λ¶€λ¨ κ΄€κ³„ μ €μ¥
int[] par = new int[N+1];  // λ¶€λ¨ λ°°μ—΄

for (int i = 1; i <= N; i++) {
    int p = scanner.nextInt();  // λ¶€λ¨
    int c = scanner.nextInt();  // μμ‹
    par[c] = p;
}
```

### 3. λ£¨νΈ μ°ΎκΈ°, μ΅°μƒ μ°ΎκΈ°

```java
// λ£¨νΈ μ°ΎκΈ° λ° μ΅°μƒ λ…Έλ“ μ°ΎκΈ°
import java.util.ArrayList;

int c = 5;  // μμ‹: 5λ² λ…Έλ“μ μ΅°μƒ μ°ΎκΈ°
ArrayList<Integer> anc = new ArrayList<>();

while (par[c] != 0) {  // λ£¨νΈμΈμ§€ ν™•μΈ
    c = par[c];
    anc.add(c);  // μ΅°μƒ λ©λ΅μ— μ¶”κ°€
}
int root = c;
```

---

## μ΄μ§„ νΈλ¦¬ μν

### μν(traversal)μ μ •μ

> νΈλ¦¬μ κ° λ…Έλ“λ¥Ό μ¤‘λ³µλμ§€ μ•κ² μ „λ¶€ λ°©λ¬Έ(visit)ν•λ” κ²ƒ
>

νΈλ¦¬λ” λΉ„μ„ ν• κµ¬μ΅°μ΄κΈ° λ•λ¬Έμ— μ„ ν•κµ¬μ΅°μ—μ„μ™€ κ°™μ΄ μ„ ν›„ μ—°κ²° κ΄€κ³„λ¥Ό μ• μ μ—†μ–΄ **νΉλ³„ν• λ°©λ²•**μ΄ ν•„μ”ν•λ‹¤.

### 3κ°€μ§€ κΈ°λ³Έμ μΈ μν λ°©λ²•

### 1. μ „μ„μν(preorder traversal): VLR

- **λ¶€λ¨λ…Έλ“ λ°©λ¬Έ ν›„**, μμ‹λ…Έλ“λ¥Ό μΆ, μ° μμ„λ΅ λ°©λ¬Έ

```java
// νΈλ¦¬ λ…Έλ“ ν΄λμ¤ μ •μ
class TreeNode {
    int data;
    TreeNode left;
    TreeNode right;

    TreeNode(int data) {
        this.data = data;
        this.left = null;
        this.right = null;
    }
}

// μ „μ„μν λ©”μ„λ“
public void preorderTraverse(TreeNode node) {
    if (node != null) {
        visit(node);  // System.out.print(node.data + " ");
        preorderTraverse(node.left);
        preorderTraverse(node.right);
    }
}
```

### 2. μ¤‘μ„μν(inorder traversal): LVR

- **μ™Όμ½ μμ‹λ…Έλ“, λ¶€λ¨λ…Έλ“, μ¤λ¥Έμ½ μμ‹λ…Έλ“** μμΌλ΅ λ°©λ¬Έ

```java
// μ¤‘μ„μν λ©”μ„λ“
public void inorderTraverse(TreeNode node) {
    if (node != null) {
        inorderTraverse(node.left);
        visit(node);  // System.out.print(node.data + " ");
        inorderTraverse(node.right);
    }
}
```

### 3. ν›„μ„μν(postorder traversal): LRV

- **μμ‹λ…Έλ“λ¥Ό μΆμ° μμ„λ΅ λ°©λ¬Έν• ν›„**, λ¶€λ¨λ…Έλ“λ΅ λ°©λ¬Έ

```java
// ν›„μ„μν λ©”μ„λ“
public void postorderTraverse(TreeNode node) {
    if (node != null) {
        postorderTraverse(node.left);
        postorderTraverse(node.right);
        visit(node);  // System.out.print(node.data + " ");
    }
}

// visit λ©”μ„λ“
private void visit(TreeNode node) {
    System.out.print(node.data + " ");
}
```

### μμ‹ νΈλ¦¬μ—μ„μ μν

μμ‹μ„ ν‘ν„ν•λ” μ΄μ§„ νΈλ¦¬μ—μ„:

- **μ¤‘μ„ μν**: A / B * C * D + E (μ‹μ μ¤‘μ„ ν‘κΈ°λ²•)
- **ν›„μ„ μν**: A B / C * D * E + (μ‹μ ν›„μ„ ν‘κΈ°λ²•)
- **μ „μ„ μν**: + * * / A B C D E (μ‹μ μ „μ„ ν‘κΈ°λ²•)

---

## (μ°Έκ³ ) μ΄μ§„ νƒμƒ‰ νΈλ¦¬

### μ΄μ§„ νƒμƒ‰ νΈλ¦¬μ μ •μ

- **νƒμƒ‰μ‘μ—…μ„ ν¨μ¨μ μΌλ΅** ν•κΈ° μ„ν• μλ£κµ¬μ΅°
- λ¨λ“  μ›μ†λ” μ„λ΅ λ‹¤λ¥Έ **μ μΌν• ν‚¤**λ¥Ό κ°–λ”λ‹¤
- **key(μ™Όμ½ μ„λΈνΈλ¦¬) < key(λ£¨νΈ λ…Έλ“) < key(μ¤λ¥Έμ½ μ„λΈνΈλ¦¬)**
- μ™Όμ½ μ„λΈνΈλ¦¬μ™€ μ¤λ¥Έμ½ μ„λΈνΈλ¦¬λ„ **μ΄μ§„ νƒμƒ‰ νΈλ¦¬**λ‹¤
- **μ¤‘μ„ μνν•λ©΄ μ¤λ¦„μ°¨μμΌλ΅ μ •λ ¬λ κ°’**μ„ μ–»μ„ μ μλ‹¤

### νƒμƒ‰ μ—°μ‚°

1. λ£¨νΈμ—μ„ μ‹μ‘ν•λ‹¤
2. νƒμƒ‰ν•  ν‚¤ κ°’ xλ¥Ό λ£¨νΈ λ…Έλ“μ ν‚¤ κ°’κ³Ό λΉ„κµν•λ‹¤
    - **(ν‚¤ κ°’ x = λ£¨νΈλ…Έλ“μ ν‚¤ κ°’)**: μ›ν•λ” μ›μ†λ¥Ό μ°Ύμ•μΌλ―€λ΅ νƒμƒ‰μ—°μ‚° μ„±κ³µ
    - **(ν‚¤ κ°’ x < λ£¨νΈλ…Έλ“μ ν‚¤ κ°’)**: λ£¨νΈλ…Έλ“μ **μ™Όμ½ μ„λΈνΈλ¦¬**μ— λ€ν•΄μ„ νƒμƒ‰μ—°μ‚° μν–‰
    - **(ν‚¤ κ°’ x > λ£¨νΈλ…Έλ“μ ν‚¤ κ°’)**: λ£¨νΈλ…Έλ“μ **μ¤λ¥Έμ½ μ„λΈνΈλ¦¬**μ— λ€ν•΄μ„ νƒμƒ‰μ—°μ‚° μν–‰
3. μ„λΈνΈλ¦¬μ— λ€ν•΄μ„ **μν™μ μΌλ΅** νƒμƒ‰ μ—°μ‚°μ„ λ°λ³µν•λ‹¤  
- (μ½”λ“ μ‘μ„± λ°©λ²•μ— λ€ν•΄μ„λ” μ°Έκ³ λ§ ν•μ„Έμ” ^^;;)

    ```java
    // μ™„μ „ν• μ΄μ§„ νƒμƒ‰ νΈλ¦¬ ν΄λμ¤
    public class BinarySearchTree {
        private TreeNode root;
    
        public BinarySearchTree() {
            this.root = null;
        }
    
        // νƒμƒ‰ μ—°μ‚°
        public TreeNode search(int key) {
            return search(root, key);
        }
    
        private TreeNode search(TreeNode node, int key) {
            if (node == null || node.data == key) {
                return node;
            }
    
            if (key < node.data) {
                return search(node.left, key);
            }
            return search(node.right, key);
        }
    
        // μ‚½μ… μ—°μ‚°
        public void insert(int key) {
            root = insert(root, key);
        }
    
        private TreeNode insert(TreeNode node, int key) {
            if (node == null) {
                return new TreeNode(key);
            }
    
            if (key < node.data) {
                node.left = insert(node.left, key);
            } else if (key > node.data) {
                node.right = insert(node.right, key);
            }
    
            return node;
        }
    
        // μ‚­μ  μ—°μ‚°
        public void delete(int key) {
            root = delete(root, key);
        }
    
        private TreeNode delete(TreeNode node, int key) {
            if (node == null) {
                return node;
            }
    
            if (key < node.data) {
                node.left = delete(node.left, key);
            } else if (key > node.data) {
                node.right = delete(node.right, key);
            } else {
                if (node.left == null) {
                    return node.right;
                } else if (node.right == null) {
                    return node.left;
                }
    
                node.data = findMin(node.right);
                node.right = delete(node.right, node.data);
            }
    
            return node;
        }
    
        private int findMin(TreeNode node) {
            while (node.left != null) {
                node = node.left;
            }
            return node.data;
        }
    
        // μ¤‘μ„ μν (μ •λ ¬λ μμ„λ΅ μ¶λ ¥)
        public void inorderTraversal() {
            inorderTraversal(root);
            System.out.println();
        }
    
        private void inorderTraversal(TreeNode node) {
            if (node != null) {
                inorderTraversal(node.left);
                System.out.print(node.data + " ");
                inorderTraversal(node.right);
            }
        }
    }
    ```


### μ‚½μ… μ—°μ‚°

1. **λ¨Όμ € νƒμƒ‰ μ—°μ‚°μ„ μν–‰**
    - μ‚½μ…ν•  μ›μ†μ™€ κ°™μ€ μ›μ†κ°€ νΈλ¦¬μ— μμΌλ©΄ μ‚½μ…ν•  μ μ—†μΌλ―€λ΅ ν™•μΈ
    - **νƒμƒ‰μ—μ„ νƒμƒ‰ μ‹¤ν¨κ°€ κ²°μ •λλ” μ„μΉκ°€ μ‚½μ… μ„μΉ**κ°€ λλ‹¤
2. **νƒμƒ‰ μ‹¤ν¨ν• μ„μΉμ— μ›μ†λ¥Ό μ‚½μ…**ν•λ‹¤

```java
// μ‚¬μ© μμ 
public class BSTExample {
    public static void main(String[] args) {
        BinarySearchTree bst = new BinarySearchTree();

        // λ…Έλ“ μ‚½μ…
        int[] values = {9, 4, 12, 3, 6, 15, 13, 17};
        for (int value : values) {
            bst.insert(value);
        }

        System.out.print("μ¤‘μ„ μν κ²°κ³Ό: ");
        bst.inorderTraversal(); // μ •λ ¬λ μμ„λ΅ μ¶λ ¥

        // νƒμƒ‰
        TreeNode found = bst.search(13);
        if (found != null) {
            System.out.println("13μ„ μ°Ύμ•μµλ‹λ‹¤.");
        }

        // μ‚­μ 
        bst.delete(13);
        System.out.print("13 μ‚­μ  ν›„: ");
        bst.inorderTraversal();
    }
}
```

### μ„±λ¥ λ¶„μ„

- **νƒμƒ‰, μ‚½μ…, μ‚­μ ** μ‹κ°„μ€ νΈλ¦¬μ λ†’μ΄λ§νΌ μ‹κ°„μ΄ κ±Έλ¦°λ‹¤: **O(h)**

### ν‰κ· μ κ²½μ°

- μ΄μ§„ νΈλ¦¬κ°€ **κ· ν•μ μΌλ΅ μƒμ„±**λμ–΄ μλ” κ²½μ°: **O(log n)**

### μµμ•…μ κ²½μ°

- **ν•μ½μΌλ΅ μΉμ°μΉ κ²½μ‚¬ μ΄μ§„νΈλ¦¬**μ κ²½μ°: **O(n)**
- μμ°¨νƒμƒ‰κ³Ό μ‹κ°„λ³µμ΅λ„κ°€ κ°™λ‹¤

### κ²€μƒ‰ μ•κ³ λ¦¬μ¦ λΉ„κµ

| μ•κ³ λ¦¬μ¦ | μ‹κ°„λ³µμ΅λ„ | νΉμ§• |
| --- | --- | --- |
| λ°°μ—΄μ—μ„μ μμ°¨ κ²€μƒ‰ | O(N) |  |
| μ •λ ¬λ λ°°μ—΄μ—μ„μ μμ°¨ κ²€μƒ‰ | O(N) |  |
| μ •λ ¬λ λ°°μ—΄μ—μ„μ μ΄μ§„νƒμƒ‰ | O(logN) | κ³ μ • λ°°μ—΄ ν¬κΈ°, μ‚½μ…/μ‚­μ  μ‹ μ¶”κ°€ μ—°μ‚° ν•„μ” |
| μ΄μ§„ νƒμƒ‰νΈλ¦¬μ—μ„μ ν‰κ·  | O(logN) | μµμ•…μ κ²½μ°: O(N) |
| ν•΄μ‰¬ κ²€μƒ‰ | O(1) | μ¶”κ°€ μ €μ¥ κ³µκ°„ ν•„μ” |

---

## ν™

### ν™μ μ •μ

- **μ™„μ „ μ΄μ§„ νΈλ¦¬**μ— μλ” λ…Έλ“ μ¤‘μ—μ„ ν‚¤κ°’μ΄ κ°€μ¥ ν° λ…Έλ“λ‚ ν‚¤κ°’μ΄ κ°€μ¥ μ‘μ€ λ…Έλ“λ¥Ό μ°ΎκΈ° μ„ν•΄μ„ λ§λ“  μλ£κµ¬μ΅°
- μ΄λ¬ν• ν™μ μ •μλ¥Ό λ§μ΅±ν•λ” μ™„μ „ μ΄μ§„ νΈλ¦¬λ¥Ό **β€heapν•λ‹¤β€™(=heapify)**λΌκ³  ν‘ν„ν•λ‹¤.

### ν™μ μΆ…λ¥

### μµλ€ ν™(max heap)

- ν‚¤κ°’μ΄ κ°€μ¥ **ν°** λ…Έλ“λ¥Ό μ°ΎκΈ° μ„ν• μ™„μ „ μ΄μ§„ νΈλ¦¬
- **{λ¶€λ¨λ…Έλ“μ ν‚¤κ°’ > μμ‹λ…Έλ“μ ν‚¤κ°’}**
- **λ£¨νΈ λ…Έλ“**: ν‚¤κ°’μ΄ κ°€μ¥ ν° λ…Έλ“

### μµμ† ν™(min heap)

- ν‚¤κ°’μ΄ κ°€μ¥ **μ‘μ€** λ…Έλ“λ¥Ό μ°ΎκΈ° μ„ν• μ™„μ „ μ΄μ§„ νΈλ¦¬
- **{λ¶€λ¨λ…Έλ“μ ν‚¤κ°’ < μμ‹λ…Έλ“μ ν‚¤κ°’}**
- **λ£¨νΈ λ…Έλ“**: ν‚¤κ°’μ΄ κ°€μ¥ μ‘μ€ λ…Έλ“

### ν™μ μ—°μ‚°

### μ‚½μ… μ—°μ‚°

1. μ™„μ „ μ΄μ§„ νΈλ¦¬ κµ¬μ΅°λ¥Ό μ μ§€ν•κΈ° μ„ν•΄ **λ§μ§€λ§‰ μ„μΉμ— μ‚½μ…**
2. **λ¶€λ¨ λ…Έλ“μ™€ λΉ„κµ**ν•μ—¬ ν™ μ΅°κ±΄μ„ λ§μ΅±ν•  λ•κΉμ§€ **μ„λ΅ μ΄λ™**(λ¶€λ¨μ™€ μλ¦¬ κµν™)

```java
// μµλ€ ν™ κµ¬ν„
class MaxHeap {
    private int[] heap;
    private int size;
    private int capacity;

    public MaxHeap(int capacity) {
        this.capacity = capacity;
        this.size = 0;
        this.heap = new int[capacity + 1]; // 1λ¶€ν„° μ‹μ‘ν•κΈ° μ„ν•΄
    }

    // μ‚½μ… μ—°μ‚°
    public void insert(int value) {
        if (size >= capacity) {
            throw new RuntimeException("Heap is full");
        }

        // λ§μ§€λ§‰ μ„μΉμ— μ‚½μ…
        size++;
        heap[size] = value;

        // μ„λ΅ μ΄λ™ν•λ©° ν™ μ΅°κ±΄ λ§μ΅±μ‹ν‚¤κΈ°
        heapifyUp(size);
    }

    private void heapifyUp(int index) {
        while (index > 1 && heap[index] > heap[index / 2]) {
            // λ¶€λ¨μ™€ μλ¦¬ κµν™
            swap(index, index / 2);
            index = index / 2;
        }
    }

    private void swap(int i, int j) {
        int temp = heap[i];
        heap[i] = heap[j];
        heap[j] = temp;
    }
}

```

### μ‚­μ  μ—°μ‚°

- ν™μ—μ„λ” **λ£¨νΈ λ…Έλ“μ μ›μ†λ§μ„ μ‚­μ **ν•  μ μλ‹¤
- λ£¨νΈ λ…Έλ“μ μ›μ†λ¥Ό μ‚­μ ν•μ—¬ λ°ν™ν•λ‹¤
- ν™μ μΆ…λ¥μ— λ”°λΌ **μµλ€κ°’ λλ” μµμ†κ°’**μ„ κµ¬ν•  μ μλ‹¤
1. **λ£¨νΈ λ…Έλ“μ μ›μ† μ‚­μ **
2. **λ§μ§€λ§‰ λ…Έλ“λ¥Ό λ£¨νΈλ΅ μ΄λ™**
3. **μμ‹ λ…Έλ“μ™€ λΉ„κµ**ν•μ—¬ ν™ μ΅°κ±΄μ„ λ§μ΅±ν•  λ•κΉμ§€ **μ•„λλ΅ μ΄λ™**(μμ‹κ³Ό μλ¦¬ κµν™)

```java
// μ‚­μ  μ—°μ‚° (μµλ€κ°’ μ¶”μ¶)
public int extractMax() {
    if (size == 0) {
        throw new RuntimeException("Heap is empty");
    }

    int max = heap[1]; // λ£¨νΈ λ…Έλ“ κ°’ μ €μ¥

    // λ§μ§€λ§‰ λ…Έλ“λ¥Ό λ£¨νΈλ΅ μ΄λ™
    heap[1] = heap[size];
    size--;

    // μ•„λλ΅ μ΄λ™ν•λ©° ν™ μ΅°κ±΄ λ§μ΅±μ‹ν‚¤κΈ°
    heapifyDown(1);

    return max;
}

private void heapifyDown(int index) {
    while (index * 2 <= size) { // μ™Όμ½ μμ‹μ΄ μ΅΄μ¬ν•λ” λ™μ•
        int leftChild = index * 2;
        int rightChild = index * 2 + 1;
        int largest = index;

        // μ™Όμ½ μμ‹κ³Ό λΉ„κµ
        if (leftChild <= size && heap[leftChild] > heap[largest]) {
            largest = leftChild;
        }

        // μ¤λ¥Έμ½ μμ‹κ³Ό λΉ„κµ
        if (rightChild <= size && heap[rightChild] > heap[largest]) {
            largest = rightChild;
        }

        // ν™ μ΅°κ±΄μ„ λ§μ΅±ν•λ©΄ μΆ…λ£
        if (largest == index) {
            break;
        }

        // μμ‹κ³Ό μλ¦¬ κµν™
        swap(index, largest);
        index = largest;
    }
}
```

### ν™μ„ μ΄μ©ν• μ°μ„ μμ„ ν

- ν™μ ν‚¤λ¥Ό **μ°μ„ μμ„λ΅ ν™μ©**ν•μ—¬ μ°μ„ μμ„ νλ¥Ό κµ¬ν„ν•  μ μλ‹¤
- **μ™„μ „ μ΄μ§„ νΈλ¦¬λ΅ κµ¬ν„λ μλ£κµ¬μ΅°**λ΅μ„, ν‚¤κ°’μ΄ κ°€μ¥ ν° λ…Έλ“λ‚ κ°€μ¥ μ‘μ€ λ…Έλ“λ¥Ό μ°ΎκΈ°μ— μ©μ΄ν• μλ£κµ¬μ΅°

---

## π“ μ—°μµ λ¬Έμ 

### μ΄μ§„ νΈλ¦¬ μν μ—°μµ

μ£Όμ–΄μ§„ νΈλ¦¬μ—μ„ μ „μ„, μ¤‘μ„, ν›„μ„ μν κ²°κ³Όλ¥Ό κµ¬ν•΄λ³΄μ„Έμ”.

```java
// μμ : νΈλ¦¬ κµ¬μ„± λ° μν ν…μ¤νΈ
public class TreeTraversalExample {
    public static void main(String[] args) {
        // νΈλ¦¬ κµ¬μ„±: A(1) - B(2), C(3) - D(4), E(5), F(6), G(7)
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);
        root.right.left = new TreeNode(6);
        root.right.right = new TreeNode(7);

        System.out.print("μ „μ„ μν: ");
        preorderTraverse(root);
        System.out.println();

        System.out.print("μ¤‘μ„ μν: ");
        inorderTraverse(root);
        System.out.println();

        System.out.print("ν›„μ„ μν: ");
        postorderTraverse(root);
        System.out.println();
    }
}
```

### μ΄μ§„ νƒμƒ‰ νΈλ¦¬ μ—°μ‚° μ—°μµ

μ£Όμ–΄μ§„ μ΄μ§„ νƒμƒ‰ νΈλ¦¬μ—μ„ 13, 12, 9λ¥Ό μ°¨λ΅€λ΅ μ‚­μ ν•΄λ³΄λ” μ•κ³ λ¦¬μ¦μ„ μƒκ°ν•΄λ³΄μ„Έμ”.

```java
// μ΄μ§„ νƒμƒ‰ νΈλ¦¬ μ‚­μ  μ—°μ‚°
public TreeNode delete(TreeNode node, int key) {
    if (node == null) {
        return node;
    }

    // μ‚­μ ν•  ν‚¤κ°€ ν„μ¬ λ…Έλ“λ³΄λ‹¤ μ‘μΌλ©΄ μ™Όμ½ μ„λΈνΈλ¦¬μ—μ„ μ‚­μ 
    if (key < node.data) {
        node.left = delete(node.left, key);
    }
    // μ‚­μ ν•  ν‚¤κ°€ ν„μ¬ λ…Έλ“λ³΄λ‹¤ ν¬λ©΄ μ¤λ¥Έμ½ μ„λΈνΈλ¦¬μ—μ„ μ‚­μ 
    else if (key > node.data) {
        node.right = delete(node.right, key);
    }
    // μ‚­μ ν•  λ…Έλ“λ¥Ό μ°Ύμ€ κ²½μ°
    else {
        // κ²½μ° 1: μμ‹μ΄ μ—†κ±°λ‚ ν• κ°λ§ μλ” κ²½μ°
        if (node.left == null) {
            return node.right;
        } else if (node.right == null) {
            return node.left;
        }

        // κ²½μ° 2: μμ‹μ΄ λ‘ κ° μλ” κ²½μ°
        // μ¤λ¥Έμ½ μ„λΈνΈλ¦¬μ—μ„ μµμ†κ°’ μ°ΎκΈ° (μ¤‘μ„ ν›„κ³„μ)
        node.data = findMin(node.right);

        // μ¤‘μ„ ν›„κ³„μ μ‚­μ 
        node.right = delete(node.right, node.data);
    }

    return node;
}

private int findMin(TreeNode node) {
    while (node.left != null) {
        node = node.left;
    }
    return node.data;
}
```